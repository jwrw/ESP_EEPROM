<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ESP_EEPROM: EEPROMClass Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ESP_EEPROM
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_e_e_p_r_o_m_class-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">EEPROMClass Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The ESP does not have a genuine EEPROM memory so this needs to be emulated using a segment of flash memory; this library improves upon the the standard library by avoiding excessive re-flashing of the flash memory.  
 <a href="class_e_e_p_r_o_m_class.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6a2fcfebd6ba13350fac9b8e1851e637"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_e_p_r_o_m_class.html#a6a2fcfebd6ba13350fac9b8e1851e637">EEPROMClass</a> (void)</td></tr>
<tr class="memdesc:a6a2fcfebd6ba13350fac9b8e1851e637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an instance of the EEPROM class based on the default EEPROM flash sector.  <a href="#a6a2fcfebd6ba13350fac9b8e1851e637">More...</a><br /></td></tr>
<tr class="separator:a6a2fcfebd6ba13350fac9b8e1851e637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab27ca4fac7c886d61b6294525b17ecf9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_e_p_r_o_m_class.html#ab27ca4fac7c886d61b6294525b17ecf9">begin</a> (size_t size)</td></tr>
<tr class="memdesc:ab27ca4fac7c886d61b6294525b17ecf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise the EEPROM system, reading from flash if there appears to be suitable data already there.  <a href="#ab27ca4fac7c886d61b6294525b17ecf9">More...</a><br /></td></tr>
<tr class="separator:ab27ca4fac7c886d61b6294525b17ecf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6fae68c926a984dfafab4c3f5a825d"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_e_p_r_o_m_class.html#a2e6fae68c926a984dfafab4c3f5a825d">read</a> (int const address)</td></tr>
<tr class="memdesc:a2e6fae68c926a984dfafab4c3f5a825d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a byte of data from an offset in the buffered EEPROM data.  <a href="#a2e6fae68c926a984dfafab4c3f5a825d">More...</a><br /></td></tr>
<tr class="separator:a2e6fae68c926a984dfafab4c3f5a825d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a4c9ed90008d133e43d30b41941214e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_e_p_r_o_m_class.html#a5a4c9ed90008d133e43d30b41941214e">write</a> (int const address, uint8_t const val)</td></tr>
<tr class="memdesc:a5a4c9ed90008d133e43d30b41941214e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a byte of data to an address within the the library's EEPROM data buffer.  <a href="#a5a4c9ed90008d133e43d30b41941214e">More...</a><br /></td></tr>
<tr class="separator:a5a4c9ed90008d133e43d30b41941214e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871f11ba6f5a43c1e9ecde1ce99dbb6b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_e_p_r_o_m_class.html#a871f11ba6f5a43c1e9ecde1ce99dbb6b">commit</a> ()</td></tr>
<tr class="memdesc:a871f11ba6f5a43c1e9ecde1ce99dbb6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the EEPROM data to the flash memory.  <a href="#a871f11ba6f5a43c1e9ecde1ce99dbb6b">More...</a><br /></td></tr>
<tr class="separator:a871f11ba6f5a43c1e9ecde1ce99dbb6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af12c26be29b81b729090d78c8247a4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_e_p_r_o_m_class.html#a4af12c26be29b81b729090d78c8247a4">commitReset</a> ()</td></tr>
<tr class="memdesc:a4af12c26be29b81b729090d78c8247a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an erase of the flash sector before committing the data.  <a href="#a4af12c26be29b81b729090d78c8247a4">More...</a><br /></td></tr>
<tr class="separator:a4af12c26be29b81b729090d78c8247a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae991983e499457e5cd1d988b35a34f71"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_e_p_r_o_m_class.html#ae991983e499457e5cd1d988b35a34f71">wipe</a> ()</td></tr>
<tr class="memdesc:ae991983e499457e5cd1d988b35a34f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force an immediate erase of the flash sector - but nothing is written.  <a href="#ae991983e499457e5cd1d988b35a34f71">More...</a><br /></td></tr>
<tr class="separator:ae991983e499457e5cd1d988b35a34f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68a1684c65c2732d9a186d4ff964c11"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_e_p_r_o_m_class.html#ad68a1684c65c2732d9a186d4ff964c11">percentUsed</a> ()</td></tr>
<tr class="memdesc:ad68a1684c65c2732d9a186d4ff964c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the percentage of EEPROM flash memory area that has been used by copies of our EEPROM data.  <a href="#ad68a1684c65c2732d9a186d4ff964c11">More...</a><br /></td></tr>
<tr class="separator:ad68a1684c65c2732d9a186d4ff964c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a5ffd5cd24f9b3efa8b85df4c8791bd"><td class="memItemLeft" align="right" valign="top"><a id="a3a5ffd5cd24f9b3efa8b85df4c8791bd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_e_p_r_o_m_class.html#a3a5ffd5cd24f9b3efa8b85df4c8791bd">end</a> ()</td></tr>
<tr class="memdesc:a3a5ffd5cd24f9b3efa8b85df4c8791bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free up storage used by the library. <br /></td></tr>
<tr class="separator:a3a5ffd5cd24f9b3efa8b85df4c8791bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1b67982183fa713c6fe2b68f5cf314"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1b1b67982183fa713c6fe2b68f5cf314"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_e_e_p_r_o_m_class.html#a1b1b67982183fa713c6fe2b68f5cf314">get</a> (int const address, T &amp;v)</td></tr>
<tr class="memdesc:a1b1b67982183fa713c6fe2b68f5cf314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain EEPROM data for a variable stored at the address.  <a href="#a1b1b67982183fa713c6fe2b68f5cf314">More...</a><br /></td></tr>
<tr class="separator:a1b1b67982183fa713c6fe2b68f5cf314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9bf1cd34ee9a67ffec7c8efe80de253"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa9bf1cd34ee9a67ffec7c8efe80de253"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_e_e_p_r_o_m_class.html#aa9bf1cd34ee9a67ffec7c8efe80de253">put</a> (int const address, const T &amp;v)</td></tr>
<tr class="memdesc:aa9bf1cd34ee9a67ffec7c8efe80de253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to the EEPROM buffer.  <a href="#aa9bf1cd34ee9a67ffec7c8efe80de253">More...</a><br /></td></tr>
<tr class="separator:aa9bf1cd34ee9a67ffec7c8efe80de253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9102b7b98206022c027bc999902a65eb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_e_p_r_o_m_class.html#a9102b7b98206022c027bc999902a65eb">length</a> ()</td></tr>
<tr class="memdesc:a9102b7b98206022c027bc999902a65eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the EEPROM buffer.  <a href="#a9102b7b98206022c027bc999902a65eb">More...</a><br /></td></tr>
<tr class="separator:a9102b7b98206022c027bc999902a65eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The ESP does not have a genuine EEPROM memory so this needs to be emulated using a segment of flash memory; this library improves upon the the standard library by avoiding excessive re-flashing of the flash memory. </p>
<p>The library maintains a copy of your 'EEPROM' data in normal RAM which you <a class="el" href="class_e_e_p_r_o_m_class.html#a2e6fae68c926a984dfafab4c3f5a825d" title="Read a byte of data from an offset in the buffered EEPROM data. ">read()</a> and <a class="el" href="class_e_e_p_r_o_m_class.html#a5a4c9ed90008d133e43d30b41941214e" title="Write a byte of data to an address within the the library&#39;s EEPROM data buffer. ">write()</a> to. To ensure this buffered data gets saved when you power-off or reset the system you must call <a class="el" href="class_e_e_p_r_o_m_class.html#a871f11ba6f5a43c1e9ecde1ce99dbb6b" title="Write the EEPROM data to the flash memory. ">commit()</a> to write the buffer to flash memory that will survive the reset. When you call <a class="el" href="class_e_e_p_r_o_m_class.html#ab27ca4fac7c886d61b6294525b17ecf9" title="Initialise the EEPROM system, reading from flash if there appears to be suitable data already there...">begin()</a> the library will check the flash memory and read the data there into the buffer so it is available to be <a class="el" href="class_e_e_p_r_o_m_class.html#a2e6fae68c926a984dfafab4c3f5a825d" title="Read a byte of data from an offset in the buffered EEPROM data. ">read()</a> by your program.</p>
<h2>Calling the library</h2>
<p>Including this library will create a variable call 'EEPROM' in your program which you use to access the EEPROM functions, such as EEPROM.begin(), EEPROM.read(), etc.</p>
<h2>Why ESP_EEPROM</h2>
<p>It is not possible to rewrite flash memory without first erasing it back to a known state. With the normal library, each <a class="el" href="class_e_e_p_r_o_m_class.html#a871f11ba6f5a43c1e9ecde1ce99dbb6b" title="Write the EEPROM data to the flash memory. ">commit()</a> of the data to flash requires an erase of the flash sector. With this revised library the sector in flash memory is used to hold multiple copies of the EEPROM data. Each time you <a class="el" href="class_e_e_p_r_o_m_class.html#a871f11ba6f5a43c1e9ecde1ce99dbb6b" title="Write the EEPROM data to the flash memory. ">commit()</a> data, it is written to a new area of flash until the sector is full. Only then does the library erase the sector to allow the next copy to be written.</p>
<p>The main drawback of erasing the flash is that it is quite slow (several 10s of ms) and during all operations on flash memory the interrupts have to be halted. Stopping interrupts will disrupt an PWM (analogWrite) outputs which can produce a noticeable disturbance in any lights attached to these. Flash memory can also only accommodate a limited number of re-flashes before it fails. This library helps extend the life of the flash memory by reducing the number of times it needs to be erased.</p>
<h2>Layout</h2>
<p>This implementation detail is hidden from you by the library but it may be helpful to understand what is happening 'under the hood'.</p>
<p>The structure held in the flash segment varies in size depending on the size requested in the call to <a class="el" href="class_e_e_p_r_o_m_class.html#ab27ca4fac7c886d61b6294525b17ecf9" title="Initialise the EEPROM system, reading from flash if there appears to be suitable data already there...">begin()</a>.</p>
<ul>
<li>4 bytes - size of a block</li>
<li>bitmap - bit 0 never written - shows state of flash after erase subsequent bits are set to the opposite for each block containing data the highest block is the latest version</li>
<li>Data versions follow consecutively - size rounded up to 4 byte boundaries and a minimum size</li>
</ul>
<p>During the <a class="el" href="class_e_e_p_r_o_m_class.html#ab27ca4fac7c886d61b6294525b17ecf9" title="Initialise the EEPROM system, reading from flash if there appears to be suitable data already there...">begin()</a> call, the library checks if the requested size matches the size of blocks held in the flash. If so, the bitmap is used to find the most recently written block and this is copied to the buffer held by the library. When data is written to flash using <a class="el" href="class_e_e_p_r_o_m_class.html#a871f11ba6f5a43c1e9ecde1ce99dbb6b" title="Write the EEPROM data to the flash memory. ">commit()</a>, then the library updates the bitmap and writes the data to the next available area in the flash segment. If there isn't room for a new copy then the sector is erased, the size and new bitmap are written, followed by the data.</p>
<h2>When to use</h2>
<p>Most of the time we need a small amount to EEPROM memory to retain settings between re-boots of the system. If your application uses a lot of EEPROM, e.g. more than half a flash segment, then you will get no benefit from using this library. Normally the sector size is 4096 bytes so don't bther with this library if your EEPROM requirement is over ~2000 bytes. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6a2fcfebd6ba13350fac9b8e1851e637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a2fcfebd6ba13350fac9b8e1851e637">&#9670;&nbsp;</a></span>EEPROMClass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EEPROMClass::EEPROMClass </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an instance of the EEPROM class based on the default EEPROM flash sector. </p>
<p>This constructor is not normally used, as including the library instantiates the required 'EEPROM' variable.</p>
<p>The EEPROM variable is then used to access the functions of this library.</p>
<p>e.g.</p><ul>
<li>EEPROM.begin(50);</li>
<li>EEPROM.put(4, myVariable);</li>
<li>EEPROM.get(4, myOtherVariable);</li>
<li>EEPROM.commit();</li>
</ul>
<p>There should not be any reason for creating a second instance of the ESP_EEPROM class and as the library assumes there is only one instance and only one EEPROM sector results may be 'unpredictable'. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab27ca4fac7c886d61b6294525b17ecf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab27ca4fac7c886d61b6294525b17ecf9">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EEPROMClass::begin </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise the EEPROM system, reading from flash if there appears to be suitable data already there. </p>
<p>To correctly initialise the library, you need to specify the size of the EEPROM area your program will need.</p>
<p>This function checks the flash sector to verify if it contains correct size data. If the size is good and the bitmap is valid then the data buffer in the library is initialised from the flash memory. This is a simplistic check and you may wish to include some check value or version number within your EEPROM data to provide additional confidence that the data is really good.</p>
<p>If the size is wrong or the bitmap appear broken then the data buffer is zeroed. Nothing is written to the flash until you call the <a class="el" href="class_e_e_p_r_o_m_class.html#a871f11ba6f5a43c1e9ecde1ce99dbb6b" title="Write the EEPROM data to the flash memory. ">commit()</a> function, which will erase the sector and write the new data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a871f11ba6f5a43c1e9ecde1ce99dbb6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a871f11ba6f5a43c1e9ecde1ce99dbb6b">&#9670;&nbsp;</a></span>commit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EEPROMClass::commit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the EEPROM data to the flash memory. </p>
<p>The flash segment for EEPROM data is erased if necessary before performing the write. The library maintains a record of whether the buffer has been changed and the write to flash is only performed if the flash does not yet have a copy of the data or if the data in the buffer has changed from what is stored in the flash memory.</p>
<dl class="section return"><dt>Returns</dt><dd>True if successful (or if no write was needed); false if the write was unsuccessful. </dd></dl>

</div>
</div>
<a id="a4af12c26be29b81b729090d78c8247a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4af12c26be29b81b729090d78c8247a4">&#9670;&nbsp;</a></span>commitReset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EEPROMClass::commitReset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform an erase of the flash sector before committing the data. </p>
<dl class="section return"><dt>Returns</dt><dd>True is all OK; false if there was a problem. </dd></dl>

</div>
</div>
<a id="a1b1b67982183fa713c6fe2b68f5cf314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b1b67982183fa713c6fe2b68f5cf314">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; EEPROMClass::get </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain EEPROM data for a variable stored at the address. </p>
<p>The variable type will determine the size of the data read from the buffer. For example the variable can be an entire struct which allows for a convenient way to maintain and access the EEPROM data.</p>
<p>The actual flash data is read in the <a class="el" href="class_e_e_p_r_o_m_class.html#ab27ca4fac7c886d61b6294525b17ecf9" title="Initialise the EEPROM system, reading from flash if there appears to be suitable data already there...">begin()</a> call and so this function only reads from the buffered data which makes it relatively fast.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The offset of the variable with the EEPROM data </td></tr>
    <tr><td class="paramname">v</td><td>The variable to hold the retrieved data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the retrieved variable </dd></dl>

</div>
</div>
<a id="a9102b7b98206022c027bc999902a65eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9102b7b98206022c027bc999902a65eb">&#9670;&nbsp;</a></span>length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t EEPROMClass::length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of the EEPROM buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>The size of hte buffer </dd></dl>

</div>
</div>
<a id="ad68a1684c65c2732d9a186d4ff964c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad68a1684c65c2732d9a186d4ff964c11">&#9670;&nbsp;</a></span>percentUsed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int EEPROMClass::percentUsed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the percentage of EEPROM flash memory area that has been used by copies of our EEPROM data. </p>
<p>Each <a class="el" href="class_e_e_p_r_o_m_class.html#a871f11ba6f5a43c1e9ecde1ce99dbb6b" title="Write the EEPROM data to the flash memory. ">commit()</a> will write a new copy to the next free area of the segment of flash memory given over to EEPROM. This routine allows you to keep track of how much has been used to anticipate when the library will next need to do a flash erase of the EEPROM sector.</p>
<p>Since version 2 the return value of -1 is used to indicate that no erase/write has been done to the flash with the current sized EEPROM data. It is important to distinguish this from the case where 1 or 2 copies of a small sized EEPROM data has been written but still might amount to 0% used (when rounded to an integer)</p>
<dl class="section return"><dt>Returns</dt><dd>The percentage used (0-100) or -1 if the flash does not hold any copies of the data. </dd></dl>

</div>
</div>
<a id="aa9bf1cd34ee9a67ffec7c8efe80de253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9bf1cd34ee9a67ffec7c8efe80de253">&#9670;&nbsp;</a></span>put()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; EEPROMClass::put </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write data to the EEPROM buffer. </p>
<p>The function checks if the data is different from that already in the buffer.</p>
<p>The data is written to the internal buffer but is only written to the flash memory in the <a class="el" href="class_e_e_p_r_o_m_class.html#a871f11ba6f5a43c1e9ecde1ce99dbb6b" title="Write the EEPROM data to the flash memory. ">commit()</a> function. The <a class="el" href="class_e_e_p_r_o_m_class.html#a871f11ba6f5a43c1e9ecde1ce99dbb6b" title="Write the EEPROM data to the flash memory. ">commit()</a> function only writes to flash if there have been changes to the buffered data (or if the buffered data has never been written to the flash previously).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_e_e_p_r_o_m_class.html#a871f11ba6f5a43c1e9ecde1ce99dbb6b" title="Write the EEPROM data to the flash memory. ">commit()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>Relative address to which to write the data within the EEPROM buffer. </td></tr>
    <tr><td class="paramname">v</td><td>The variable to write to the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The variable written to the buffer </dd></dl>

</div>
</div>
<a id="a2e6fae68c926a984dfafab4c3f5a825d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e6fae68c926a984dfafab4c3f5a825d">&#9670;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t EEPROMClass::read </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a byte of data from an offset in the buffered EEPROM data. </p>
<p>The data is actually read from the flash during the call to <a class="el" href="class_e_e_p_r_o_m_class.html#ab27ca4fac7c886d61b6294525b17ecf9" title="Initialise the EEPROM system, reading from flash if there appears to be suitable data already there...">begin()</a> so this call just read from that buffered copy and so is pretty fast.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_e_e_p_r_o_m_class.html#a1b1b67982183fa713c6fe2b68f5cf314" title="Obtain EEPROM data for a variable stored at the address. ">get()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The offset in the data buffer to read from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The byte at the specified address. </dd></dl>

</div>
</div>
<a id="ae991983e499457e5cd1d988b35a34f71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae991983e499457e5cd1d988b35a34f71">&#9670;&nbsp;</a></span>wipe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EEPROMClass::wipe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force an immediate erase of the flash sector - but nothing is written. </p>
<p>The internal library variables &amp; data are initialised (zeroed) but the <a class="el" href="class_e_e_p_r_o_m_class.html#a871f11ba6f5a43c1e9ecde1ce99dbb6b" title="Write the EEPROM data to the flash memory. ">commit()</a> function must be called to write structure (size and bitmap etc.) and any new data to the flash.</p>
<dl class="section return"><dt>Returns</dt><dd>True is success; false if the erase operation failed. </dd></dl>

</div>
</div>
<a id="a5a4c9ed90008d133e43d30b41941214e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a4c9ed90008d133e43d30b41941214e">&#9670;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EEPROMClass::write </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t const&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a byte of data to an address within the the library's EEPROM data buffer. </p>
<p>This call just updates the internal data buffer. You must call <a class="el" href="class_e_e_p_r_o_m_class.html#a871f11ba6f5a43c1e9ecde1ce99dbb6b" title="Write the EEPROM data to the flash memory. ">commit()</a> to actual write your data to flash so that it can be retained between restarts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The offset with the EEPROM to which to write the data </td></tr>
    <tr><td class="paramname">value</td><td>The byte of data to write to the address </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/jim/Developer/Arduino/Sketches/libraries/ESP_EEPROM/src/<a class="el" href="_e_s_p___e_e_p_r_o_m_8h_source.html">ESP_EEPROM.h</a></li>
<li>/Users/jim/Developer/Arduino/Sketches/libraries/ESP_EEPROM/src/ESP_EEPROM.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
